{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mappers \u00b6 Declarative mappers to domain entities. Documentation | Source Code | Task Tracker Pros \u00b6 Entities are: Single responsibility Interface segregation Testable Automated work with data stores. Prevent serialization process leak into entities. Questions \u00b6 If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose. License \u00b6 Mappers library is offered under the two clause BSD license. \u2014 \u2b50\ufe0f \u2014 The mappers library is part of the SOLID python family.","title":"Home"},{"location":"#mappers","text":"Declarative mappers to domain entities. Documentation | Source Code | Task Tracker","title":"Mappers"},{"location":"#pros","text":"Entities are: Single responsibility Interface segregation Testable Automated work with data stores. Prevent serialization process leak into entities.","title":"Pros"},{"location":"#questions","text":"If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose.","title":"Questions"},{"location":"#license","text":"Mappers library is offered under the two clause BSD license. \u2014 \u2b50\ufe0f \u2014 The mappers library is part of the SOLID python family.","title":"License"},{"location":"changelog/","text":"2.1.0 (2020-06-26) \u00b6 Features \u00b6 introduce iterable reader ( ac359b1 ) 2.0.3 (2020-05-01) \u00b6 Bug Fixes \u00b6 support one to one relations in django models ( 7bd4cfc ), closes #154 use flat structure to represent data source schema ( 980f41f ), closes #222 #185 2.0.2 (2020-04-28) \u00b6 Bug Fixes \u00b6 consider Any as an optional type when performing the nullable check ( 3087af3 ) 2.0.1 (2020-04-19) \u00b6 Bug Fixes \u00b6 show function name in the reader representation ( 96b9b44 ), closes #123 2.0.0 (2020-04-19) \u00b6 Features \u00b6 deprecate typing api ( 33ce208 ) BREAKING CHANGES \u00b6 See #197 1.1.0 (2020-04-19) \u00b6 Features \u00b6 implement decorators based API ( 596ee2f ), closes #197 1.0.2 (2020-03-21) \u00b6 Bug Fixes \u00b6 the nullable check can handle a generic foreign key field ( ffcb665 ), closes #183 1.0.1 (2020-02-11) \u00b6 Bug Fixes \u00b6 prevent generated changelog from style guide violation ( b23aa34 ) 1.0.0 (2020-02-10) \u00b6 Bug Fixes \u00b6 recognize pydantic allow none type as optional entity field ( 3260b56 ) \u2014 \u2b50\ufe0f \u2014 The mappers library is part of the SOLID python family.","title":"Changelog"},{"location":"changelog/#210-2020-06-26","text":"","title":"2.1.0 (2020-06-26)"},{"location":"changelog/#features","text":"introduce iterable reader ( ac359b1 )","title":"Features"},{"location":"changelog/#203-2020-05-01","text":"","title":"2.0.3 (2020-05-01)"},{"location":"changelog/#bug-fixes","text":"support one to one relations in django models ( 7bd4cfc ), closes #154 use flat structure to represent data source schema ( 980f41f ), closes #222 #185","title":"Bug Fixes"},{"location":"changelog/#202-2020-04-28","text":"","title":"2.0.2 (2020-04-28)"},{"location":"changelog/#bug-fixes_1","text":"consider Any as an optional type when performing the nullable check ( 3087af3 )","title":"Bug Fixes"},{"location":"changelog/#201-2020-04-19","text":"","title":"2.0.1 (2020-04-19)"},{"location":"changelog/#bug-fixes_2","text":"show function name in the reader representation ( 96b9b44 ), closes #123","title":"Bug Fixes"},{"location":"changelog/#200-2020-04-19","text":"","title":"2.0.0 (2020-04-19)"},{"location":"changelog/#features_1","text":"deprecate typing api ( 33ce208 )","title":"Features"},{"location":"changelog/#breaking-changes","text":"See #197","title":"BREAKING CHANGES"},{"location":"changelog/#110-2020-04-19","text":"","title":"1.1.0 (2020-04-19)"},{"location":"changelog/#features_2","text":"implement decorators based API ( 596ee2f ), closes #197","title":"Features"},{"location":"changelog/#102-2020-03-21","text":"","title":"1.0.2 (2020-03-21)"},{"location":"changelog/#bug-fixes_3","text":"the nullable check can handle a generic foreign key field ( ffcb665 ), closes #183","title":"Bug Fixes"},{"location":"changelog/#101-2020-02-11","text":"","title":"1.0.1 (2020-02-11)"},{"location":"changelog/#bug-fixes_4","text":"prevent generated changelog from style guide violation ( b23aa34 )","title":"Bug Fixes"},{"location":"changelog/#100-2020-02-10","text":"","title":"1.0.0 (2020-02-10)"},{"location":"changelog/#bug-fixes_5","text":"recognize pydantic allow none type as optional entity field ( 3260b56 ) \u2014 \u2b50\ufe0f \u2014 The mappers library is part of the SOLID python family.","title":"Bug Fixes"},{"location":"faq/","text":"FAQ \u00b6 I want to reuse a reader inside another reader \u00b6 Use private functions for it. It's the best option available. It's not necessary to copypaste filter logic from one reader to another just to build something slitely different on top of it. >>> from dataclasses import dataclass >>> @dataclass ... class User : ... primary_key : int ... name : str >>> from mappers import Mapper >>> from django_project.models import UserTable >>> mapper = Mapper ( User , UserTable , { 'primary_key' : 'id' }) >>> def _load_users (): ... return UserTable . objects . all () >>> load_users = mapper . reader . sequence ( _load_users ) >>> @mapper . reader . entity ... def load_user ( primary_key ): ... return _load_users () . filter ( pk = primary_key ) >>> load_users () # doctest: +ELLIPSIS [ User ( primary_key = 1 , ... ), User ( primary_key = 2 , ... )] >>> load_user ( 1 ) # doctest: +ELLIPSIS User ( primary_key = 1 , ... )","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#i-want-to-reuse-a-reader-inside-another-reader","text":"Use private functions for it. It's the best option available. It's not necessary to copypaste filter logic from one reader to another just to build something slitely different on top of it. >>> from dataclasses import dataclass >>> @dataclass ... class User : ... primary_key : int ... name : str >>> from mappers import Mapper >>> from django_project.models import UserTable >>> mapper = Mapper ( User , UserTable , { 'primary_key' : 'id' }) >>> def _load_users (): ... return UserTable . objects . all () >>> load_users = mapper . reader . sequence ( _load_users ) >>> @mapper . reader . entity ... def load_user ( primary_key ): ... return _load_users () . filter ( pk = primary_key ) >>> load_users () # doctest: +ELLIPSIS [ User ( primary_key = 1 , ... ), User ( primary_key = 2 , ... )] >>> load_user ( 1 ) # doctest: +ELLIPSIS User ( primary_key = 1 , ... )","title":"I want to reuse a reader inside another reader"},{"location":"installation/","text":"Installation \u00b6 The mappers library is available on PyPI. To install it run: pip install -U mappers \u2014 \u2b50\ufe0f \u2014 The mappers library is part of the SOLID python family.","title":"Installation"},{"location":"installation/#installation","text":"The mappers library is available on PyPI. To install it run: pip install -U mappers \u2014 \u2b50\ufe0f \u2014 The mappers library is part of the SOLID python family.","title":"Installation"},{"location":"usage/","text":"Usage \u00b6 One to one mapping \u00b6 Define an entity with dataclass \u00b6 >>> from dataclasses import dataclass >>> from datetime import datetime >>> from typing import NewType >>> UserId = NewType ( \"UserId\" , int ) >>> @dataclass ... class User : ... primary_key : UserId ... created : datetime ... modified : datetime ... name : str ... about : str ... avatar : str Define data source with django model \u00b6 >>> from django.db import models >>> class UserTable ( models . Model ): ... created = models . DateTimeField ( auto_now_add = True ) ... modified = models . DateTimeField ( auto_now = True ) ... name = models . CharField ( max_length = 255 ) ... about = models . TextField () ... avatar = models . FileField () ... ... class Meta : ... app_label = \"app\" Define a reader mapper \u00b6 >>> from mappers import Mapper >>> from django_project.models import UserTable >>> mapper = Mapper ( User , UserTable , { \"primary_key\" : \"id\" }) >>> @mapper . reader . sequence ... def load_users (): ... \"\"\"Load all users from the database.\"\"\" ... return UserTable . objects . all () Read list of domain entities directly from data source \u00b6 >>> load_users () # doctest: +ELLIPSIS [User(primary_key=1, created=datetime.datetime(...), modified=datetime.datetime(...), name='', about='', avatar=''), ...] Mapping evaluated field \u00b6 Define an entity with dataclass \u00b6 >>> from dataclasses import dataclass >>> from typing import NewType >>> ChatId = NewType ( \"ChatId\" , int ) >>> @dataclass ... class Chat : ... primary_key : ChatId ... name : str ... is_hidden : bool Define data source with django model \u00b6 >>> from django.db import models >>> class ChatTable ( models . Model ): ... name = models . CharField ( max_length = 255 ) ... subscribers = models . ManyToManyField ( ... \"UserTable\" , ... related_name = \"chats\" , ... through = \"SubscriptionTable\" , ... ) ... ... class Meta : ... app_label = \"app\" >>> class SubscriptionTable ( models . Model ): ... user = models . ForeignKey ( ... \"UserTable\" , ... related_name = \"chat_subscriptions\" , ... on_delete = models . CASCADE , ... ) ... chat = models . ForeignKey ( ... \"ChatTable\" , ... related_name = \"chat_subscriptions\" , ... on_delete = models . CASCADE , ... ) ... ... class Meta : ... app_label = \"app\" Define a reader mapper \u00b6 >>> from django.db import models >>> from mappers import Mapper , Evaluated >>> from django_project.models import ChatTable , SubscriptionTable >>> mapper = Mapper ( Chat , ChatTable , { ... \"primary_key\" : \"id\" , ... \"is_hidden\" : Evaluated (), ... }) >>> @mapper . reader . sequence ... def load_chats ( user : User ): ... \"\"\"Load all chats from the point of view of the logged-in user.\"\"\" ... subscription = SubscriptionTable . objects . filter ( ... user = user . primary_key , ... chat = models . OuterRef ( \"pk\" ) ... ) ... chats = ChatTable . objects . annotate ( ... is_hidden =~ models . Exists ( subscription ), ... ) ... return chats Read list of domain entities directly from data source \u00b6 >>> load_chats ( load_users ()[ 0 ]) # doctest: +ELLIPSIS [Chat(primary_key=1, name='', is_hidden=False), ...] Mapping with nested objects \u00b6 Define an entity with an nested entity \u00b6 >>> from dataclasses import dataclass >>> from typing import NewType >>> MessageId = NewType ( \"MessageId\" , int ) >>> @dataclass ... class Message : ... primary_key : MessageId ... user : User ... text : str ... ... def written_by ( self , user : User ) -> bool : ... return self . user . primary_key == user . primary_key Define data source with django model \u00b6 >>> from django.db import models >>> class MessageTable ( models . Model ): ... user = models . ForeignKey ( ... \"UserTable\" , ... related_name = \"messages\" , ... on_delete = models . CASCADE , ... ) ... text = models . TextField () ... ... class Meta : ... app_label = \"app\" Define a reader mapper \u00b6 >>> from mappers import Mapper >>> from django_project.models import MessageTable >>> mapper = Mapper ( Message , MessageTable , { ... \"primary_key\" : \"id\" , ... \"user\" : Mapper ({ ... \"primary_key\" : \"id\" , ... }), ... }) >>> @mapper . reader . sequence ... def load_messages (): ... \"\"\"Load list of all messages.\"\"\" ... return MessageTable . objects . all () Read list of domain entities directly from data source \u00b6 >>> messages = load_messages () >>> messages # doctest: +ELLIPSIS [Message(primary_key=1, user=User(primary_key=1, ...), text=''), ...] >>> messages [ 0 ] . written_by ( load_users ()[ 0 ]) True >>> messages [ 1 ] . written_by ( load_users ()[ 0 ]) False","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#one-to-one-mapping","text":"","title":"One to one mapping"},{"location":"usage/#define-an-entity-with-dataclass","text":">>> from dataclasses import dataclass >>> from datetime import datetime >>> from typing import NewType >>> UserId = NewType ( \"UserId\" , int ) >>> @dataclass ... class User : ... primary_key : UserId ... created : datetime ... modified : datetime ... name : str ... about : str ... avatar : str","title":"Define an entity with dataclass"},{"location":"usage/#define-data-source-with-django-model","text":">>> from django.db import models >>> class UserTable ( models . Model ): ... created = models . DateTimeField ( auto_now_add = True ) ... modified = models . DateTimeField ( auto_now = True ) ... name = models . CharField ( max_length = 255 ) ... about = models . TextField () ... avatar = models . FileField () ... ... class Meta : ... app_label = \"app\"","title":"Define data source with django model"},{"location":"usage/#define-a-reader-mapper","text":">>> from mappers import Mapper >>> from django_project.models import UserTable >>> mapper = Mapper ( User , UserTable , { \"primary_key\" : \"id\" }) >>> @mapper . reader . sequence ... def load_users (): ... \"\"\"Load all users from the database.\"\"\" ... return UserTable . objects . all ()","title":"Define a reader mapper"},{"location":"usage/#read-list-of-domain-entities-directly-from-data-source","text":">>> load_users () # doctest: +ELLIPSIS [User(primary_key=1, created=datetime.datetime(...), modified=datetime.datetime(...), name='', about='', avatar=''), ...]","title":"Read list of domain entities directly from data source"},{"location":"usage/#mapping-evaluated-field","text":"","title":"Mapping evaluated field"},{"location":"usage/#define-an-entity-with-dataclass_1","text":">>> from dataclasses import dataclass >>> from typing import NewType >>> ChatId = NewType ( \"ChatId\" , int ) >>> @dataclass ... class Chat : ... primary_key : ChatId ... name : str ... is_hidden : bool","title":"Define an entity with dataclass"},{"location":"usage/#define-data-source-with-django-model_1","text":">>> from django.db import models >>> class ChatTable ( models . Model ): ... name = models . CharField ( max_length = 255 ) ... subscribers = models . ManyToManyField ( ... \"UserTable\" , ... related_name = \"chats\" , ... through = \"SubscriptionTable\" , ... ) ... ... class Meta : ... app_label = \"app\" >>> class SubscriptionTable ( models . Model ): ... user = models . ForeignKey ( ... \"UserTable\" , ... related_name = \"chat_subscriptions\" , ... on_delete = models . CASCADE , ... ) ... chat = models . ForeignKey ( ... \"ChatTable\" , ... related_name = \"chat_subscriptions\" , ... on_delete = models . CASCADE , ... ) ... ... class Meta : ... app_label = \"app\"","title":"Define data source with django model"},{"location":"usage/#define-a-reader-mapper_1","text":">>> from django.db import models >>> from mappers import Mapper , Evaluated >>> from django_project.models import ChatTable , SubscriptionTable >>> mapper = Mapper ( Chat , ChatTable , { ... \"primary_key\" : \"id\" , ... \"is_hidden\" : Evaluated (), ... }) >>> @mapper . reader . sequence ... def load_chats ( user : User ): ... \"\"\"Load all chats from the point of view of the logged-in user.\"\"\" ... subscription = SubscriptionTable . objects . filter ( ... user = user . primary_key , ... chat = models . OuterRef ( \"pk\" ) ... ) ... chats = ChatTable . objects . annotate ( ... is_hidden =~ models . Exists ( subscription ), ... ) ... return chats","title":"Define a reader mapper"},{"location":"usage/#read-list-of-domain-entities-directly-from-data-source_1","text":">>> load_chats ( load_users ()[ 0 ]) # doctest: +ELLIPSIS [Chat(primary_key=1, name='', is_hidden=False), ...]","title":"Read list of domain entities directly from data source"},{"location":"usage/#mapping-with-nested-objects","text":"","title":"Mapping with nested objects"},{"location":"usage/#define-an-entity-with-an-nested-entity","text":">>> from dataclasses import dataclass >>> from typing import NewType >>> MessageId = NewType ( \"MessageId\" , int ) >>> @dataclass ... class Message : ... primary_key : MessageId ... user : User ... text : str ... ... def written_by ( self , user : User ) -> bool : ... return self . user . primary_key == user . primary_key","title":"Define an entity with an nested entity"},{"location":"usage/#define-data-source-with-django-model_2","text":">>> from django.db import models >>> class MessageTable ( models . Model ): ... user = models . ForeignKey ( ... \"UserTable\" , ... related_name = \"messages\" , ... on_delete = models . CASCADE , ... ) ... text = models . TextField () ... ... class Meta : ... app_label = \"app\"","title":"Define data source with django model"},{"location":"usage/#define-a-reader-mapper_2","text":">>> from mappers import Mapper >>> from django_project.models import MessageTable >>> mapper = Mapper ( Message , MessageTable , { ... \"primary_key\" : \"id\" , ... \"user\" : Mapper ({ ... \"primary_key\" : \"id\" , ... }), ... }) >>> @mapper . reader . sequence ... def load_messages (): ... \"\"\"Load list of all messages.\"\"\" ... return MessageTable . objects . all ()","title":"Define a reader mapper"},{"location":"usage/#read-list-of-domain-entities-directly-from-data-source_2","text":">>> messages = load_messages () >>> messages # doctest: +ELLIPSIS [Message(primary_key=1, user=User(primary_key=1, ...), text=''), ...] >>> messages [ 0 ] . written_by ( load_users ()[ 0 ]) True >>> messages [ 1 ] . written_by ( load_users ()[ 0 ]) False","title":"Read list of domain entities directly from data source"}]}